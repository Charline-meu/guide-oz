[{"id":0,"href":"/guide-oz/docs/tp/tp1/","title":"Séance 1","section":"TP","content":"Séance 1 #  Question 1 #  % Exécutez le programme en utilisant \u0026#34;Feed Region\u0026#34; pour le bloc code % Ou \u0026#34;Feed Line\u0026#34; pour la ligne de code {Browse 1} {Browse 2} {Browse 3} {Browse 4} Question 2 #  {Browse 19 - 970} {Browse 192 - 980 + 191*967} {Browse (192-780)*(~3) - 191*967} Question 3 #  % On ne peut pas utiliser les types flottants et entiers ensemble % en oz donc on doit les convertir pour faire des opérations {Browse 123 + {FloatToInt 456.0}} {Browse {IntToFloat 123} + 456.0} Question 4 #  De simples exemples :\ndeclare X = 19 Y = 970 {Browse X+Y} % X et Y sont utilisables entre le local et le end local X Y in X = 19 Y = 970 {Browse X+Y} end Question 5 #  Question 6 #  Question 7 #  declare fun {SignOfInteger X} if X == 0 then 0 elseif X \u0026gt; 0 then 1 else ~1 end end Question 8 #  local P Q X Y Z in % (1) local Y in % Premier changement Y=X fun {P X} X*Y+Z % (2) end end local Z in % Second changement Z = Y fun {Q Y} X*Y+Z % (3) end end X=1 Y=2 Z=3 {Browse {P 4}} {Browse {Q 4}} {Browse {Q {P 4}}} % (4) end Question 9 #  Somme des carrés #  declare fun {SquareSum X} {SquareSumAux X 0} end fun {SquareSumAux X Acc} if X == 0 then Acc else {SquareSum X-1 Acc+X*X} end end {Browse {SquareSum 6}} Autre synthaxe que vous verrez plus tard mise ici pour l\u0026rsquo;exemple.\ndeclare fun {SquareSum X} fun {SquareSumAux X Acc} if X == 0 then Acc else {SquareSumAux X-1 Acc+X*X} end end in {SquareSumAux X 0} end {Browse {SquareSum 6}} Miroir, mon beau miroir\u0026hellip; #  declare fun {Miror N} {MirorAux N 0} end fun {MirorAux N I} if N==0 then I else {MirorAux (N div 10) I*10+N mod 10} end end {Browse {Miror 146587234}} Univers parallèle #  Partie 1 #  Partie2 #  Un, deux, trois, nous irons au bois #  declare proc {Countdown N} if N == 0 then {Browse 0} else {Browse N} {Countdown (N-1)} end end {Countdown 5} "},{"id":1,"href":"/guide-oz/docs/tp/tp2/","title":"Séance 2","section":"TP","content":"Séance 2 #  Question 1 #  declare % Définitions L1 = a|nil L2 = a|(b|c|nil)|d|nil L3 = proc {$} {Browse oui} end|proc{$} {Browse non} end|nil L4 = est|une|liste|nil L5 = (a|p|nil)|nil % Nouvelle list en ajoutant ceci NewList = ceci|L4 % Appel de la première procédure {L3.1} % Obtention de [[b c] d] End = L2.2 % Fonction head et tail fun {Head L} case L of H|_ then H else nil end end fun {Tail L} case L of _|T then T else nil end end Question 2 #  declare fun {Length L} fun {LengthAcc L Acc} case L of nil then Acc [] _|T then {LengthAcc T Acc+1} end end in {LengthAcc L 0} end Question 3 #  declare fun {Append L1 L2} case L1 of H|T then H|{Append T L2} [] nil then L2 end end Question 4 #  declare fun {IsEmpty L} case L of nil then empty [] _|_ then nonEmpty else other end end Question 5 #  declare fun {Take Xs N} case Xs of H|T then if N\u0026gt;0 then H|{Take T N-1} else nil end [] nil then nil end end fun {Drop Xs N} case Xs of H|T then if N\u0026gt;0 then {Drop T N-1} else Xs end [] nil then nil end end Question 6 #  declare fun {MultList L} fun {MulListAcc L Acc} case L of nil then Acc [] H|T then {MulListAcc T H*Acc} end end in {MulListAcc L 1} end Question 7 #  declare L1 = [[1 2 3] [4 5 6]] L2 = (1|2|3|nil)|(4|5|6|nil)|nil L3 = (1|(2|(3|nil)))|(4|(5|(6|nil)))|nil Question 8 #  declare fun {Prefix L1 L2} case L1 of H1|T1 then case L2 of H2|T2 then if H1 == H2 then {Prefix T1 T2} else false end [] nil then false end [] nil then true end end fun {FindString S T} IndexMax = {Length T} - {Length S} + 1 fun {FindStringHelp L1 L2 I} if I =\u0026lt; IndexMax then if {Prefix L1 L2} then I|{FindStringHelp L1 L2.2 I+1} else {FindStringHelp L1 L2.2 I+1} end else nil end end in {FindStringHelp S T 1} end Question 9 #  declare Carte = carte(menu(entree: \u0026#39;salade verte aux lardons\u0026#39; plat: \u0026#39;steak frites\u0026#39; prix: 10) menu(entree: \u0026#39;salade de crevettes grises\u0026#39; plat: \u0026#39;saumon fume et pommes de terre\u0026#39; prix: 12) menu(plat: \u0026#39;choucroute garnie\u0026#39; prix: 9)) {Browse Carte.2} % Second menu {Browse Carte.2.plat} % Plat second menu {Browse Carte.1.entree} % Entree second menu % Ce sont des string. Des listes d\u0026#39;entiers inteprétés comme des char. % Permet de calculer le prix si N1 personnes prennent le menu 1 etc fun {GetPrice C N1 N2 N3} N1 * C.1.prix + N2 * C.2.prix + N3 * C.3.prix end % Arité de la carte 3 et celle des menus 3 aussi je dirais sauf le dernier à 2 Question 10 #  Question 11 #  declare fun {DictionnaryFilter D F} case D of dict(key: Key info: Info left: Left right: Right) then if {F D.info} then Key#Info|{DictionaryFilter Left F}|{DictionnaryFilter Right F} else {DictionaryFilter Left F}|{DictionaryFilter Right F} end [] leaf then nil end end local Class Old Value in Class = dict(key:10 info:person(\u0026#39;Christian\u0026#39; 19) left:dict(key:7 info:person(\u0026#39;Denys\u0026#39; 25) left:leaf right:dict(key:9 info:person(\u0026#39;David\u0026#39; 7) left:leaf right:leaf))leaf right:dict(key:18 info:person(\u0026#39;Rose\u0026#39; 12) left:dict(key:14 info:person(\u0026#39;Ann\u0026#39; 27) left:leaf right:leaf) right:leaf)) fun {Old Info} Info.2 \u0026gt; 20 end % Val --\u0026gt; [7#person(\u0026#39;Denys\u0026#39; 25) 14#person(\u0026#39;Ann\u0026#39; 27)] {Browse {DictionaryFilter Class Old }} end Question 12 #  {Browse {IsTuple \u0026#39;|\u0026#39;(a b)}} %-\u0026gt;true, not a list {Browse {IsTuple state(1 a 2)}} %-\u0026gt;true, not a list {Browse {IsTuple a#b#c}} %-\u0026gt;true {Browse {IsList \u0026#39;|\u0026#39;(a \u0026#39;|\u0026#39;(b nil))}} %-\u0026gt;true {Browse {IsTuple state(1 3:2 2:a)}} %-\u0026gt;true, not a list, even if fields not in order {Browse {IsList [a b c]}} %-\u0026gt;true {Browse {IsList \u0026#39;|\u0026#39;(2:nil a)}} %-\u0026gt;true {Browse {IsTuple tree(v:a b c)}} %-\u0026gt;false, it is a record {Browse {IsTuple m|n|o}}%-\u0026gt;true, not a list Question 13 #  declare fun {Applique L F} case L of H|T then {F H}|{Applique T F} [] nil then nil end end fun {Lol X} lol(X) end {Browse {Applique [1 2 3] Lol}} fun {MakeAdder N} fun{$ X} X+N end end Add5 = {MakeAdder 5} {Browse {Add5 13}} fun {AddAll L N} Add = {MakeAdder N} in {Applique L Add} end {Browse {AddAll [1 2 3] 4}} Question 14 #  "},{"id":2,"href":"/guide-oz/docs/tp/tp3/","title":"Séance 3","section":"TP","content":"Séance 3 #  Question 1 #  Partie 1 #  declare proc {SumKernel N ?R} local One NEqualsOne in One = 1 NEqualsOne = (N == One) if NEqualsOne then R = One else local V NMinusOne NTimesN in NMinusOne = N-One NTimesN = N*N {SumKernel NMinusOne V} R = NTimesN + V end end end end A {SumKernel 10 A} {Browse A} Partie 2 #  declare proc {SumAuxKernel N Acc ?R} local One NEqualsOne in One = 1 NEqualsOne = (N==One) if NEqualsOne then R = Acc + One else local NMinusOne NTimesN NewAcc in NMinusOne = N - One NTimesN = N * N NewAcc = NTimesN + Acc {SumAuxKernel NMinusOne NewAcc R} end end end end proc {SumKernel N ?R} {SumAuxKernel N 0 R} end A {SumKernel 10 A} {Browse A} Cette fonction est résurvive terminale\nQuestion 2 #  declare A = \u0026#39;|\u0026#39;(1:1 2:nil) B = \u0026#39;|\u0026#39;(1:1 2:\u0026#39;|\u0026#39;(1:2 2:\u0026#39;|\u0026#39;(1:3 2:nil))) C = nil D = state(1:4 2:f 3:3) {Browse A} {Browse B} {Browse C} {Browse D} Question 3 #  proc {Q A} {P A+1} end % Ec = {P -\u0026gt; p} proc {P} {Browse A} end % Ec = {Browse-\u0026gt;browse, A -\u0026gt; a} local P Q in proc {P A R} R=A+2 end % Ec = {} local P R in fun {Q A} {P A R} R end % Ec = {R -\u0026gt; r, P -\u0026gt; p} proc {P A R} R=A-2 end % Ec = {} end end "},{"id":3,"href":"/guide-oz/docs/tp/tp4/","title":"Séance 4","section":"TP","content":"Séance 4 #  Question 1 #   cf. Slide 4-6 cours 4  Question 2 #  declare fun {MakeMulFilter N} fun {$ I} I mod N == 0 end end fun {IsPrime N} fun {IsPrimeAcc N Acc} if N =\u0026lt;1 then false elseif N==Acc then true else if {{MakeMulFilter Acc} N} then false else {IsPrimeAcc N Acc+1} end end end in {IsPrimeAcc N 2} end fun {Filter L F} fun {FilterAcc L F Acc} case L of nil then Acc [] H|T then if {F H} then {FilterAcc T F H|Acc} else {FilterAcc T F Acc} end end end in {FilterAcc L F nil} end Digits = [0 1 2 3 4 5 6 7 8 9] MultipleOf2 = {MakeMulFilter 2} MultipleOf3 = {MakeMulFilter 3} % Le résultat est dans l\u0026#39;ordre inverse parce que j\u0026#39;ai utilisé un accumulateur % Vous pouvez soit ne pas en utiliser, soit faire un {List.reverse L} pour ravoir le bon ordre % Ici on ne précisait pas de garder l\u0026#39;ordre donc je ne me suis pas tracassé {Browse {Filter Digits MultipleOf2}} {Browse {Filter Digits MultipleOf3}} {Browse {Filter Digits IsPrime}} Question 3 #  declare fun {FoldL L F A} case L of nil then A [] H|T then {FoldL T F {F H A}} end end fun {MultiplyList L} {FoldL L fun {$ X Y} X*Y end 1} end fun {SubstractList L} {FoldL L fun {$ X Y} Y-X end 0} end Digits = [1 2 3 4 5 6 7 8 9] Brr = [1 2 3 4] {Browse {MultiplyList Digits}} {Browse {DiffList Brr}} Question 4 #  declare fun {Applique L F} case L of nil then nil [] H|T then {F H}|{Applique T F} end end fun {Pow N E} fun {Pow N E Acc} case E of 0 then Acc else {Pow N E-1 N*Acc} end end in {Pow N E 1} end fun {PowE E} fun {$ N} {Pow N E} end end fun {PowList L E} {Applique L {PowE E}} end {Browse {PowList [1 2 3] 2}} Question 5 #  declare fun {Convertir T V} T*V end fun {ConvertirBetter T} fun {$ V} T*V end end fun {ConvertirBetter2 A B} fun {$ V} A*V+B end end PiedVersMetre = {ConvertirBetter 0.30480370641307} FarenheitToCelcius = {ConvertirBetter2 0.56 ~17.78} {Browse {PiedVersMetre 3.0}} {Browse {FarenheitToCelcius 3.0}} Question 6 #  declare fun {PipeLine N} P1 P2 P3 in P1 = {GenerateList N} P2 = {MyFilter P1 fun {$ X} X mod 2 \\= 0 end} P3 = {MyMap P2 fun {$ X} X * X end} {MyFoldL P3 fun {$ Acc X} X + Acc end 0} end fun {GenerateList N} fun {GenerateListAcc N Acc} case N of 0 then Acc else {GenerateListAcc N-1 N|Acc} end end in {GenerateListAcc N nil} end fun {MyFilter L F} fun {FilterAcc L F Acc} case L of nil then Acc [] H|T then if {F H} then {FilterAcc T F H|Acc} else {FilterAcc T F Acc} end end end in {FilterAcc L F nil} end fun {MyMap L F} fun {MyMapAcc L F A} case L of nil then A [] H|T then {MyMapAcc T F {F H}|A} end end in {MyMapAcc L F nil} end fun {MyFoldL L F Acc} case L of nil then Acc [] H|T then {MyFoldL T F {F Acc H}} end end {Browse {PipeLine 10}} Question 7 #  local Y LB in Y=10 proc {LB X ?Z} if X\u0026gt;=Y then Z=X else Z=Y end end local Y=15 Z in {LB 5 Z} % Affiche 1O car le Y utilisé par LB est celui % de son contexte pas de celui où LB est appelé {Browse Z} end end "},{"id":4,"href":"/guide-oz/docs/tp/tp5/","title":"Séance 5","section":"TP","content":"Séance 5 #  Question 1 #  1. [X] λx.xyz 2. [ ] λx.λy 3. [X] m 4. [X] xλwy.y 5. [ ] xλ 6. [ ] λλxz.zx 7. [X] (mnop)(qrst)vwλxyz.zxy  Question 2 #  1. (λx(λy.x)) 2. (λx(λx.x)) 3. (λx.x(λy.x)) 4. (λx.x(λx.x)) 5. (λz.x(λy.x)) 6. (λz.x(λx.x))  Question 3 #  1. [X] λa.λb.abb λb.λa.baa 2. [ ] λa.λb.λa.bb λi.λj.jji 3. [ ] λx.xλy.x λe.eλf.f 4. [X] λx.xλy.x λe.eλf.e  Question 4 #  1. yy 2. ayya 3. - (λx.(λz.zx)q)y - (λz.zy)q - qy 4. - (λx.x((λz.zx)(λx.bx)))y - y((λz.zy)(λx.bx)) - y(y(λx.bx)) - y(by) 5. - (λm.m)(λn.n)(λc.cc)(λd.d) - (λm.m)(λn.n)(λc.(λd.d)(λd.d)) - (λm.m)(λn.(λc.(λd.d)(λd.d))) - (λm.λn.λc.(λd.d)(λd.d))) - (λd.(λd.d)) - (λd.d) 6. - λz.xλx.x  Question 5 #  1. - λx.(λy.y)x - λy.y 2. - λx.(λy.(λz.p)y)x - λy.(λz.p)y - λz.p 3. - λx.(λy.(λz.z))x - λy.(λz.z) 4. - λx.(λy.yx)p 5. - (λf.fx)(λy.gy) - (λy.gy)x - (λf.fx)g  Question 6 #  1.1 - (λx. λy. x) ((λx. x) y) - (λx.λy. x) (λy. y) - (λx. x) (λy. y) - λy. y 1.2 - (λx. λy. x) ((λx. x) y) - λy.(λx. x)y - λy. y 2.1 - (λx.λy. xy) (λz. z) (λw. w) - (λy. (λw. w)y) (λz. z) - (λw. w)(λz. z) - (λw. w) 2.2 - (λx.λy. xy) (λz. z) (λw. w) - (λx. x(λz. z))(λw. w) - (λw. w)(λz. z) - λz.z  Question 7 #  NOT ≜ λp.p false true OR ≜ λp.λq p p q OR TRUE FALSE ≜ (λp.λq.p) true false  Question 8 #  SUCC ≜ λn.λf.λx.f (n f x)  Question 9 #  FIRST ≜ λp.p true FIRST ≜ λa.λb. a SECOND ≜ λp.p false SECOND ≜ λa.λb. b PAIR ≜ λx.λy.λf.f x y λf.f 4 2 FIRST -\u0026gt; true 4 2 -\u0026gt; 4 SECOND -\u0026gt; false 4 2 -\u0026gt; 2 List ≜ λf.f h t  Question 10 #  Question 11 #  Question 12 #  "},{"id":5,"href":"/guide-oz/docs/tp/tp6/","title":"Séance 6","section":"TP","content":"Séance 6 #  Question 1 #  declare fun {Reverse L} C = {NewCell nil} in for E in L do C := E|@C end @C end {Browse {Reverse [1 2 3 4 5]}} Question 2 #  declare fun {NewStack} {NewCell nil} end fun {IsEmpty S} @S == nil end proc {Push S X} S := X|@S end fun {Pop S} if {IsEmpty S} then nil else R in R = @S.1 S := @S.2 R end end fun {Eval Xs} S = {NewStack} in for X in Xs do case X of \u0026#39;+\u0026#39; then {Push S {Pop S} + {Pop S}} [] \u0026#39;-\u0026#39; then Op1 Op2 in Op1 = {Pop S} Op2 = {Pop S} {Push S Op2 - Op1} [] \u0026#39;*\u0026#39; then {Push S {Pop S} * {Pop S}} [] \u0026#39;/\u0026#39; then Op1 Op2 in Op1 = {Pop S} Op2 = {Pop S} {Push S Op2 div Op1} [] N then {Push S N} end end {Pop S} end {Browse {Eval [13 45 \u0026#39;+\u0026#39; 89 17 \u0026#39;-\u0026#39; \u0026#39;*\u0026#39;]}} % affiche 4176 = (13+45)*(89-17) {Browse {Eval [13 45 \u0026#39;+\u0026#39; 89 \u0026#39;*\u0026#39; 17 \u0026#39;-\u0026#39;]}} % affiche 5145 = ((13+45)*89)-17 {Browse {Eval [13 45 89 17 \u0026#39;-\u0026#39; \u0026#39;+\u0026#39; \u0026#39;*\u0026#39;]}} % affiche 1521 Question 3 #  declare fun {NewStack} C = {NewCell nil} fun {IsEmpty} @C == nil end proc {Push X} C := X|@C end fun {Pop} if {IsEmpty} then nil else S in S=@C.1 C:=@C.2 S end end in stack(isEmpty:IsEmpty push:Push pop:Pop) end declare fun {NewStack} C = {NewCell nil} fun {IsEmpty} @C == nil end proc {Push X} C := X|@C end fun {Pop} if {IsEmpty} then nil else S in S=@C.1 C:=@C.2 S end end in stack(isEmpty:IsEmpty push:Push pop:Pop) end fun {Eval Xs} S = {NewStack} in for X in Xs do case X of \u0026#39;+\u0026#39; then {S.push {S.pop}+{S.pop}} [] \u0026#39;-\u0026#39; then Op1 Op2 in Op1 = {S.pop} Op2 = {S.pop} {S.push Op2-Op1} [] \u0026#39;*\u0026#39; then {S.push {S.pop}*{S.pop}} [] \u0026#39;/\u0026#39; then Op1 Op2 in Op1 = {S.pop} Op2 = {S.pop} {S.push Op2 div Op1} [] N then {S.push N} end end {S.pop} end {Browse {Eval [13 45 \u0026#39;+\u0026#39; 89 17 \u0026#39;-\u0026#39; \u0026#39;*\u0026#39;]}} % affiche 4176 = (13+45)*(89-17) {Browse {Eval [13 45 \u0026#39;+\u0026#39; 89 \u0026#39;*\u0026#39; 17 \u0026#39;-\u0026#39;]}} % affiche 5145 = ((13+45)*89)-17 {Browse {Eval [13 45 89 17 \u0026#39;-\u0026#39; \u0026#39;+\u0026#39; \u0026#39;*\u0026#39;]}} % affiche 1521 Question 4 #  declare fun {Shuffle L} I A B Li Picked in I = {NewCell 0} A = {NewArray 0 {Length L} 0} for X in L do A.@I := X I := @I +1 end Picked = {NewCell 0} B = {NewArray 0 {Length L} 0} for N in 0..({Length L}-1) do R in R = {OS.rand} mod ({Length L} -N) {Browse R} Picked := A.R B.N := @Picked A.R := A.({Length L}-N-1) end Li = {NewCell nil} for Ind in 0..({Length L}-1) do Li :=(B.({Length L}-1-Ind))|@Li end @Li end {Browse {Shuffle [a b c d e]}} Question 5 #  L1 est une liste mais pas L2.\nQuestion 6 #  declare class Collection attr elements meth init % initialise la collection elements:=nil end meth put(X) % insere X elements:=X|@elements end meth get($) % extrait un element et le renvoie case @elements of X|Xr then elements:=Xr X end end meth isEmpty($) % renvoie true ssi la collection est vide @elements==nil end meth union(C) if {Not {C isEmpty($)}} then {self put({C get($)})} {self union(C)} end end meth toList($) @elements end end declare class SortedCollection from Collection meth put(X) fun {PutHelp L} case L of H|T then if H \u0026lt; X then H |{PutHelp T} else X|L end [] nil then X|L end end in elements := {PutHelp @elements} end end C1 = {New SortedCollection init} C2 = {New Collection init} {C1 put(0)} {C1 put(1)} {C2 put(2)} {C2 put(1)} {C2 put(3)} {Browse {C1 toList($)}} {Browse {C2 toList($)}} {C1 union(C2)} {Browse {C2 isEmpty($)}} {Browse {C1 isEmpty($)}} {Browse {C1 toList($)}} {Browse {C1 get($)}} {Browse {C1 toList($)}} % if C1 , C2 are Collections , union is O (|C2|) % because put is O (1) % if C1 , C2 are SortedCollections , % union is O (|C2|^2 + |C1|*|C2|) %proof : %(n1 + (n1+1) + (n1+2) + ... + (n1+n2-1)) %~= (n1 + (n1+1) + (n1 +2) + ... + (n1+n2)) %= n2*n1 + (0+1+2+...+ n2) % = n2*n1 + 0.5*n2*(n2+1) % ~= n2*n1 + 0.5*n2*n2 % =\u0026gt; O(n2^2 + n2*n1 ) declare Xs = [7 8 0 4 3] C3 = {New SortedCollection init} for X in Xs do {C3 put(X)} end {Browse {C3 toList($)}} % insertion sort O (n^2) Question 7 #  declare class Constante attr value meth init(V) value := V end meth evalue($) @value end meth derive(V $) {New Constante init(0)} end end class Variable attr value meth init(V) value := V end meth evalue($) @value end meth derive(V E) if self == V then E = {New Constante init(1)} else E = {New Constante init(0)} end end meth set(V) value := V end end class Somme attr e1 e2 meth init(Expr1 Expr2) e1 := Expr1 e2 := Expr2 end meth evalue($) {@e1 evalue($)} + {@e2 evalue($)} end meth derive(V $) {New Somme init({@e1 derive(V $)} {@e2 derive(V $)})} end end class Difference attr e1 e2 meth init(Expr1 Expr2) e1 := Expr1 e2 := Expr2 end meth evalue($){@e1 evalue($)} - {@e2 evalue($)} end meth derive(V $) {New Difference init({@e1 derive(V $)} {@e2 derive(V $)}) } end end class Produit attr e1 e2 meth init(Expr1 Expr2) e1 := Expr1 e2 := Expr2 end meth evalue($) {@e1 evalue($)} * {@e2 evalue($) } end meth derive(V $) D1 D2 in D1 = {New Produit init({@e1 derive(V $)} @e2)} D2 = {New Produit init({@e2 derive(V $) } @e1 ) } {New Somme init(D1 D2) } end end class Puissance attr e1 c meth init(Expr1 C) e1 := Expr1 c := C end meth evalue($) {Pow {@e1 evalue($)}@c } end meth derive(V $) De1 P CP in De1 = {@e1 derive(V $)} P = {New Puissance init(@e1 @c -1)} CP ={New Produit init({ New Constante init(@c)} P)} {New Produit init(CP De1)} end end VarX ={New Variable init(0)} VarY ={New Variable init(0)} local ExprX2 ={New Puissance init(VarX 2) } Expr3 ={New Constante init(3) } Expr3X2 ={New Produit init(Expr3 ExprX2) } ExprXY ={New Produit init(VarX VarY) } Expr3X2mXY ={New Difference init(Expr3X2 ExprXY)} ExprY3 ={New Puissance init(VarY 3)} in Formule ={New Somme init(Expr3X2mXY ExprY3)} end {VarX set(7)} {VarY set(23)} {Browse {Formule evalue($) }} % affiche 12153 {VarX set(5)} {VarY set(8)} {Browse {Formule evalue($)}} % affiche 547 declare Derivee ={Formule derive(VarX $) } % represente 6 x - y {VarX set(7)} {VarY set(23)} {Browse {Derivee evalue($)}} % affiche 19 "},{"id":6,"href":"/guide-oz/docs/installation/","title":"Installation de Mozart2","section":"Docs","content":"Installation de Mozart2 #  Sélectionnez votre système d\u0026rsquo;exploitation :\n Linux Macos Windows  "},{"id":7,"href":"/guide-oz/docs/installation/vscode/","title":"VSCode","section":"Installation de Mozart2","content":"Visual Studio Code #  Dans Visual Studio Code allez dans l\u0026rsquo;onglet extensions et cherchez après l\u0026rsquo;extension Oz posté par Mozart. Vous devrez ensuite modifier les paramètres de l\u0026rsquo;extension.\n La première est le linting que vous pouvez activer La deuxième est Oz: Ozengine Path où vous devez mettre le chemin vers ozengine. Ce chemin change selon les OS donc voici les chemins pour chacun d\u0026rsquo;eux.  Linux #  Arch #  /usr/bin/ozengine\nMacOS #  /usr/local/Caskroom/mozart2/2.0.1/Mozart2.app/Contents/Resources/bin/ozengine\nWindows #  Le chemin dépend d\u0026rsquo;où vous avez installé Mozart. Allez là où vous l\u0026rsquo;avez installé et cherchez un fichier appelé ozengine.\n"},{"id":8,"href":"/guide-oz/docs/tp/","title":"TP","section":"Docs","content":"Solutions des séances de TP #  Les solutions présentées ici ne sont pas celles données par le professeur. Il se peut donc que les solutions ne soient pas optimales ou que vous en ayez de différentes qui fonctionnent aussi.\nEssayez de faire les exercices par vous-même avant de lire les solutions.\n Séance 1 Séance 2 Séance 3 Séance 4 Séance 5 Séance 6  "},{"id":9,"href":"/guide-oz/docs/installation/windows/","title":"Windows","section":"Installation de Mozart2","content":"Windows #  Installation #  Téléchargez l\u0026rsquo;installateur de mozart2 pour Windows en cliquant ici. Exécutez ensuite le programme et procédez à l\u0026rsquo;installation. Durant cette dernière il est vous est proposé de créer un raccourci et je vous conseille de le faire.\nLancer l\u0026rsquo;environnement de développement #  Cliquez sur le raccourci nommé Mozart Programming Interface ou tapez Mozart dans la barre de recherche Windows. Une version d\u0026rsquo;Emacs configurée pour Mozart2 devrait alors s\u0026rsquo;ouvrir. Amusez-vous bien!\nProblèmes connus #  L\u0026rsquo;application que vous tentez d\u0026rsquo;installer n\u0026rsquo;est pas vérifiée\u0026hellip; #   Cliquez sur Installer quand même  "},{"id":10,"href":"/guide-oz/docs/installation/macos/","title":"Macos","section":"Installation de Mozart2","content":"MacOS #  Prérequis #  Homebrew #  Rendez-vous sur le site de Homebrew et suivez les instructions d\u0026rsquo;installation disponibles sur la page d\u0026rsquo;accueil du site. Toutes les commandes qui suivent utilisent Homebrew donc vous devez l\u0026rsquo;installer en premier.\nEmacs #  N\u0026rsquo;importe quelle version d\u0026rsquo;Emacs fera l\u0026rsquo;affaire cependant le professeur recommande Aquamacs.\nAquamacs #  brew install --cask aquamacs Installation #  D\u0026rsquo;abord, clonez le répertoire qui contient Mozart2 en tapant la commande suivante dans votre terminal:\nbrew tap dskecse/tap Ensuite, installez Mozart2 avec la commande suivante:\nbrew install --cask mozart2 Deux applications se nommant Emacs et Mozart2 devraient à présent se trouver dans votre dossier Applications. Si MacOs vous empêche de les lancer, ouvrez Finder et cliquez droit sur l\u0026rsquo;application puis cliquez sur ouvrir.\nEn cliquant sur Mozart2, une version d\u0026rsquo;Emacs configurée pour Mozart2 devrait alors s\u0026rsquo;ouvrir. Amusez-vous bien!\nProblèmes connus #  Bug des parenthèses #  Cliquez ici pour suivre le guide permettant de résoudre ce problème.\n"},{"id":11,"href":"/guide-oz/docs/installation/linux/","title":"Linux","section":"Installation de Mozart2","content":"Linux #  Installation #  Chaque distribution de Linux a sa propre méthode d\u0026rsquo;installation. Référez-vous donc à celle de votre distribution.\nArch #  Installez Yay.\ngit clone https://aur.archlinux.org/yay.git cd yay makepkg -si Ensuite installez mozart.\nyay -Sy mozart2 Ubuntu #  Tutoriel complet ici\nLancer l\u0026rsquo;environnement de développement #  oz "}]