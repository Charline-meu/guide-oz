<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TP on Guide OZ</title><link>https://ahzed11.github.io/guide-oz/docs/tp/</link><description>Recent content in TP on Guide OZ</description><generator>Hugo -- gohugo.io</generator><language>fr-be</language><lastBuildDate>Tue, 01 Feb 2022 14:59:53 +0100</lastBuildDate><atom:link href="https://ahzed11.github.io/guide-oz/docs/tp/index.xml" rel="self" type="application/rss+xml"/><item><title>Séance 1</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp1/</link><pubDate>Tue, 01 Feb 2022 14:31:20 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp1/</guid><description>Séance 1 # Question 1 # % Exécutez le programme en utilisant &amp;quot;Feed Region&amp;quot; pour le bloc code % Ou &amp;quot;Feed Line&amp;quot; pour la ligne de code {Browse 1} {Browse 2} {Browse 3} {Browse 4} Question 2 # {Browse 19 - 970} {Browse 192 - 980 + 191*967} {Browse (192-780)*(~3) - 191*967} Question 3 # % On ne peut pas utiliser les types flottants et entiers ensemble % en oz donc on doit les convertir pour faire des opérations {Browse 123 + {FloatToInt 456.</description></item><item><title>Séance 2</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp2/</link><pubDate>Wed, 09 Feb 2022 10:00:46 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp2/</guid><description>Séance 2 # Question 1 # declare % Définitions L1 = a|nil L2 = a|(b|c|nil)|d|nil L3 = proc {$} {Browse oui} end|proc{$} {Browse non} end|nil L4 = est|une|liste|nil L5 = (a|p|nil)|nil % Nouvelle list en ajoutant ceci NewList = ceci|L4 % Appel de la première procédure {L3.1} % Obtention de [[b c] d] End = L2.2 % Fonction head et tail fun {Head L} case L of H|_ then H else nil end end fun {Tail L} case L of _|T then T else nil end end Question 2 # declare fun {Length L} fun {LengthAcc L Acc} case L of nil then Acc [] _|T then {LengthAcc T Acc+1} end end in {LengthAcc L 0} end Question 3 # declare fun {Append L1 L2} case L1 of H|T then H|{Append T L2} [] nil then L2 end end Question 4 # declare fun {IsEmpty L} case L of nil then empty [] _|_ then nonEmpty else other end end Question 5 # declare fun {Take Xs N} case Xs of H|T then if N&amp;gt;0 then H|{Take T N-1} else nil end [] nil then nil end end fun {Drop Xs N} case Xs of H|T then if N&amp;gt;0 then {Drop T N-1} else Xs end [] nil then nil end end Question 6 # declare fun {MultList L} fun {MulListAcc L Acc} case L of nil then Acc [] H|T then {MulListAcc T H*Acc} end end in {MulListAcc L 1} end Question 7 # declare L1 = [[1 2 3] [4 5 6]] L2 = (1|2|3|nil)|(4|5|6|nil)|nil L3 = (1|(2|(3|nil)))|(4|(5|(6|nil)))|nil Question 8 # declare fun {Prefix L1 L2} case L1 of H1|T1 then case L2 of H2|T2 then if H1 == H2 then {Prefix T1 T2} else false end [] nil then false end [] nil then true end end fun {FindString S T} IndexMax = {Length T} - {Length S} + 1 fun {FindStringHelp L1 L2 I} if I =&amp;lt; IndexMax then if {Prefix L1 L2} then I|{FindStringHelp L1 L2.</description></item></channel></rss>