<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TP on Guide OZ</title><link>https://ahzed11.github.io/guide-oz/docs/tp/</link><description>Recent content in TP on Guide OZ</description><generator>Hugo -- gohugo.io</generator><language>fr-be</language><lastBuildDate>Tue, 01 Feb 2022 14:59:53 +0100</lastBuildDate><atom:link href="https://ahzed11.github.io/guide-oz/docs/tp/index.xml" rel="self" type="application/rss+xml"/><item><title>Séance 1</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp1/</link><pubDate>Tue, 01 Feb 2022 14:31:20 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp1/</guid><description>Séance 1 # Question 1 # % Exécutez le programme en utilisant &amp;#34;Feed Region&amp;#34; pour le bloc code % Ou &amp;#34;Feed Line&amp;#34; pour la ligne de code {Browse 1} {Browse 2} {Browse 3} {Browse 4} Question 2 # {Browse 19 - 970} {Browse 192 - 980 + 191*967} {Browse (192-780)*(~3) - 191*967} Question 3 # % On ne peut pas utiliser les types flottants et entiers ensemble % en oz donc on doit les convertir pour faire des opérations {Browse 123 + {FloatToInt 456.</description></item><item><title>Séance 2</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp2/</link><pubDate>Wed, 09 Feb 2022 10:00:46 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp2/</guid><description>Séance 2 # Question 1 # declare % Définitions L1 = a|nil L2 = a|(b|c|nil)|d|nil L3 = proc {$} {Browse oui} end|proc{$} {Browse non} end|nil L4 = est|une|liste|nil L5 = (a|p|nil)|nil % Nouvelle list en ajoutant ceci NewList = ceci|L4 % Appel de la première procédure {L3.1} % Obtention de [[b c] d] End = L2.2 % Fonction head et tail fun {Head L} case L of H|_ then H else nil end end fun {Tail L} case L of _|T then T else nil end end Question 2 # declare fun {Length L} fun {LengthAcc L Acc} case L of nil then Acc [] _|T then {LengthAcc T Acc+1} end end in {LengthAcc L 0} end Question 3 # declare fun {Append L1 L2} case L1 of H|T then H|{Append T L2} [] nil then L2 end end Question 4 # declare fun {IsEmpty L} case L of nil then empty [] _|_ then nonEmpty else other end end Question 5 # declare fun {Take Xs N} case Xs of H|T then if N&amp;gt;0 then H|{Take T N-1} else nil end [] nil then nil end end fun {Drop Xs N} case Xs of H|T then if N&amp;gt;0 then {Drop T N-1} else Xs end [] nil then nil end end Question 6 # declare fun {MultList L} fun {MulListAcc L Acc} case L of nil then Acc [] H|T then {MulListAcc T H*Acc} end end in {MulListAcc L 1} end Question 7 # declare L1 = [[1 2 3] [4 5 6]] L2 = (1|2|3|nil)|(4|5|6|nil)|nil L3 = (1|(2|(3|nil)))|(4|(5|(6|nil)))|nil Question 8 # declare fun {Prefix L1 L2} case L1 of H1|T1 then case L2 of H2|T2 then if H1 == H2 then {Prefix T1 T2} else false end [] nil then false end [] nil then true end end fun {FindString S T} IndexMax = {Length T} - {Length S} + 1 fun {FindStringHelp L1 L2 I} if I =&amp;lt; IndexMax then if {Prefix L1 L2} then I|{FindStringHelp L1 L2.</description></item><item><title>Séance 3</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp3/</link><pubDate>Tue, 15 Feb 2022 11:29:43 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp3/</guid><description>Séance 3 # Question 1 # Partie 1 # declare proc {SumKernel N ?R} local One NEqualsOne in One = 1 NEqualsOne = (N == One) if NEqualsOne then R = One else local V NMinusOne NTimesN in NMinusOne = N-One NTimesN = N*N {SumKernel NMinusOne V} R = NTimesN + V end end end end A {SumKernel 10 A} {Browse A} Partie 2 # declare proc {SumAuxKernel N Acc ?</description></item><item><title>Séance 4</title><link>https://ahzed11.github.io/guide-oz/docs/tp/tp4/</link><pubDate>Tue, 22 Feb 2022 15:40:34 +0100</pubDate><guid>https://ahzed11.github.io/guide-oz/docs/tp/tp4/</guid><description>Séance 4 # Question 1 # cf. Slide 4-6 cours 4 Question 2 # declare fun {MakeMulFilter N} fun {$ I} I mod N == 0 end end fun {IsPrime N} fun {IsPrimeAcc N Acc} if N =&amp;lt;1 then false elseif N==Acc then true else if {{MakeMulFilter Acc} N} then false else {IsPrimeAcc N Acc+1} end end end in {IsPrimeAcc N 2} end fun {Filter L F} fun {FilterAcc L F Acc} case L of nil then Acc [] H|T then if {F H} then {FilterAcc T F H|Acc} else {FilterAcc T F Acc} end end end in {FilterAcc L F nil} end Digits = [0 1 2 3 4 5 6 7 8 9] MultipleOf2 = {MakeMulFilter 2} MultipleOf3 = {MakeMulFilter 3} % Le résultat est dans l&amp;#39;ordre inverse parce que j&amp;#39;ai utilisé un accumulateur % Vous pouvez soit ne pas en utiliser, soit faire un {List.</description></item></channel></rss>